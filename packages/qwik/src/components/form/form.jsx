// GENERATED BY MITOSIS

import {
  Fragment,
  Slot,
  component$,
  h,
  useCleanup$,
  useClientEffect$,
  useRef,
  useStore,
} from "@builder.io/qwik";
export const onInput = function onInput(props, state, formRef, event) {
  void (async function () {
    const saveCache = async function () {
      localStorage.setItem(props?.cacheKey, JSON.stringify(props?.formData));
    };
    const setFilteredValue = async function (key, value) {
      let newValue = value;
      for (const filter of typeof props?.filterData === "string"
        ? props?.filterData.split(",")
        : props?.filterData) {
        if (typeof filter !== "function") continue;
        const filterName =
          Object.getOwnPropertyDescriptors(filter)?.name?.value;
        if (!filterName || filterName !== key) continue;
        newValue = await filter(value);
      }
      return newValue;
    };
    const setByPath = function (obj, path, value) {
      const pList = path.split(".");
      const len = pList.length;
      for (let i = 0; i < len - 1; i++) {
        const elem = pList[i];
        if (!obj[elem]) obj[elem] = {};
        obj = obj[elem];
      }
      obj[pList[len - 1]] = value;
      return obj;
    };
    console.log(event, state.formData);
    if (!event?.target?.name?.startsWith?.("ion-")) {
      const value =
        typeof event?.detail?.checked === "boolean"
          ? event.detail.checked
          : event?.detail?.value || event?.target?.value;
      state.formData = setByPath(
        state?.formData || {},
        event?.target?.name,
        props?.filterData?.length
          ? await setFilteredValue(event?.target?.name, value)
          : value
      );
      if (props.cacheKey) await saveCache();
      if (!state?.hasChanged) {
        state.hasChanged = true;
      }
    }
  })();
};
export const submit = function submit(props, state, formRef, event) {
  (event?.target || document).dispatchEvent(
    new CustomEvent("fireenjinSubmit", {
      bubbles: true,
      detail: {
        event,
        data: state?.formData || null,
      },
    })
  );
};
export const Form = component$((props) => {
  const formRef = useRef();
  const state = useStore({
    eventListeners: ["ionInput", "ionChange", "ionSelect", "input", "change"],
    formData: {},
    hasChanged: false,
  });
  useClientEffect$(() => {
    if (props.formData) state.formData = props.formData;
    if (props.eventListeners) state.eventListeners = props.eventListeners;
    const ref =
      (formRef?.addEventListener && formRef) ||
      (formRef?.current?.addEventListener && formRef.current);
    if (ref?.addEventListener)
      state.eventListeners.map((eventName) =>
        ref.addEventListener(
          eventName,
          onInput.bind(null, props, state, formRef).bind(this)
        )
      );
  });
  useCleanup$(() => {
    const ref =
      (formRef?.addEventListener && formRef) ||
      (formRef?.current?.addEventListener && formRef.current);
    (props?.eventListeners || []).map((eventName) =>
      ref.removeEventListener(
        eventName,
        onInput.bind(null, props, state, formRef).bind(this)
      )
    );
  });
  return (
    <form
      preventdefault:submit=""
      ref={formRef}
      onSubmit$={(event) => {
        event.preventDefault();
        submit(props, state, formRef, event);
      }}
      action={props?.action}
      method={props?.method}
    >
      <Slot></Slot>
      <button type="submit">Save</button>
    </form>
  );
});
export default Form;
